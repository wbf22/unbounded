<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>monet</title>

    <link rel="icon" type="image/png" href="assets/favicon/android-chrome-192x192.png">
    <link rel="icon" type="image/x-icon" href="assets/favicon/favicon.ico">
    <link rel="icon" sizes="32x32" href="assets/favicon/favicon-32x32.png">
    <link rel="icon" sizes="16x16" href="assets/favicon/favicon-16x16.png">
    <link rel="manifest" href="assets/favicon/manifest.json">
</head>
<body>
    <style>

        :root {
            --primary-color: #ff8222; /* Example primary color */
            --secondary-color: #fdfeff; /* Example secondary color */
            --accent-color: #2b2b2b; /* Example accent color */
            --background-color: #e0e0e0; /* Example background color */
            --text: #2b2b2b;
            --shadow: rgba(186, 186, 186, 0.5);
        }

        body{
            margin: 0;
            display: inline-block;
        }

        #paint_canvas {
            background-color: var(--secondary-color);
            image-rendering: pixelated;

            position: absolute;
            left: 40000px;
            top: 40000px;

            border: 1px solid white;
            background-color: rgba(255, 255, 255, 0);            
        }

        #paint-background {
            background-color: #e0e0e0;
            height: 80000px;
            width: 80000px;
            z-index: 0;

        }

        .menu{
            position: fixed;
            height: 100%;
            z-index: 1;
            background-color: var(--secondary-color);
            box-shadow: 0px 0px 10px 0 var(--shadow);
            /* background-color: #585858; */
        }

        .menu_button {
            padding: .5rem;
        }

        #draw_button_sub_menu {
            display: none;
            position: fixed;
            background-color: var(--secondary-color);
            padding: 8px;
            z-index: 10; /* Make sure it appears above other content */
            border-radius: 4px;

            flex-direction: column;
            box-shadow: 0px 0px 10px 0 var(--shadow);
        }

        /* Show the hidden div when hovering over either div */
        #draw_button:hover #draw_button_sub_menu {
            display: block;
        }

        #color_icon {
            width: 40rem;
            height: 3rem;
            background-color: var(--primary-color);
            box-shadow: 0px 0px 10px 0 var(--shadow);
            margin: .3rem;
        }

        #color_choice {
            display: flex;
            flex-direction: column;
        }

        .menu_text {
            color: var(--accent-color);
        }

        .color-picker {
            text-align: center;
        }

        .slider {

            box-shadow: 0px 0px 10px 0 var(--shadow);
            margin: .3rem;
        }

        .slider::-webkit-slider-thumb, .slider::-moz-range-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px; 
            height: 20px; 
            background: white; 
            border: 2px solid #ccc; 
            border-radius: 50%;
            cursor: pointer;
        }

        #hue_slider {
            -webkit-appearance: none; /* Remove default styling for WebKit browsers */
            appearance: none; /* Remove default styling for other browsers */
            width: 40rem;
            height: 20px;
            background: linear-gradient(to right, 
                hsl(0, 100%, 50%),
                hsl(30, 100%, 50%),
                hsl(60, 100%, 50%),
                hsl(90, 100%, 50%),
                hsl(120, 100%, 50%),
                hsl(150, 100%, 50%),
                hsl(180, 100%, 50%),
                hsl(210, 100%, 50%),
                hsl(240, 100%, 50%),
                hsl(270, 100%, 50%),
                hsl(300, 100%, 50%),
                hsl(330, 100%, 50%)
            );
            border-radius: 15px;
            outline: none;
        }

        #saturation_slider {
            -webkit-appearance: none; /* Remove default styling for WebKit browsers */
            appearance: none; /* Remove default styling for other browsers */
            width: 40rem;
            height: 20px;
            background: linear-gradient(to right, 
                hsl(30, 0%, 50%),
                hsl(30, 50%, 50%),
                hsl(30, 100%, 50%)
            );
            border-radius: 10px;
            outline: none;
        }

        #lightness_slider {
            -webkit-appearance: none; /* Remove default styling for WebKit browsers */
            appearance: none; /* Remove default styling for other browsers */
            width: 40rem;
            height: 20px;
            background: linear-gradient(to right, 
                hsl(30, 100%, 0%),
                hsl(30, 100%, 10%),
                hsl(30, 100%, 20%),
                hsl(30, 100%, 30%),
                hsl(30, 100%, 40%),
                hsl(30, 100%, 50%),
                hsl(30, 100%, 60%),
                hsl(30, 100%, 70%),
                hsl(30, 100%, 80%),
                hsl(30, 100%, 90%),
                hsl(30, 100%, 100%)
            );
            border-radius: 15px;
            outline: none;
        }

        #alpha_slider {
            -webkit-appearance: none; /* Remove default styling for WebKit browsers */
            appearance: none; /* Remove default styling for other browsers */
            width: 40rem;
            height: 20px;
            background: linear-gradient(to right, 
                hsl(30, 100%, 50%, 0%),
                hsl(30, 100%, 50%, 10%),
                hsl(30, 100%, 50%, 20%),
                hsl(30, 100%, 50%, 30%),
                hsl(30, 100%, 50%, 40%),
                hsl(30, 100%, 50%, 50%),
                hsl(30, 100%, 50%, 60%),
                hsl(30, 100%, 50%, 70%),
                hsl(30, 100%, 50%, 80%),
                hsl(30, 100%, 50%, 90%),
                hsl(30, 100%, 50%, 100%)
            );
            border-radius: 15px;
            outline: none;
        }

        #alpha_back {
            background-color: var(--background-color);
            width: 40rem;
            height: 20px;
            border-radius: 15px;
            outline: none;
        }

        .color_value_text {
            color: var(--text);
            border: 1px solid var(--accent-color); 
            border-radius: 3px;
            font-size: 1rem;
            text-align: center;
        }

        .color_format_label {
            color: var(--text);
        }

        #color_format_grid {
            display: grid;
            grid-template-columns: .1fr 1fr;
            grid-gap: .3rem;
            margin: .3rem;
        }

        #color_format_grid > * {
            padding: .5rem;
        }

        #move_button {
            height: 3rem;
            width: 3rem;

            display: flex;
            justify-content: center;
            align-items: center;
        }


        .tooltip-text {
            visibility: hidden;
            background-color: var(--secondary-color);
            box-shadow: 0px 0px 10px 0 var(--shadow);
            color: var(--text);
            text-align: center;
            border-radius: 5px;
            padding: 5px;
            position: fixed;
            z-index: 400;
            opacity: 0; /* Initially hidden */
            transition: opacity 0.3s;
            font-size: 1.2rem;
        }

        #draw_button:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        #move_button:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        #draw_size_grid {
            display: grid;
            grid-template-columns: 1fr;
        }

        #draw_size_label {
            margin: .3rem;
            padding: 0.5rem;
        }

        #draw_size_slider {
            -webkit-appearance: none; /* Remove default styling for WebKit browsers */
            appearance: none; /* Remove default styling for other browsers */
            width: 40rem;
            height: 10px;
            background: var(--secondary-color);
            border-radius: 15px;
            outline: none;
        }

        #draw_size_circle {
            margin: .8rem;
            background-color: var(--primary-color);
            width: 10px;
            height: 10px;
            border-radius: 10px;
            box-shadow: 0px 0px 10px 0 var(--shadow);
        }

    </style>
    
    <!-- draw sub menu -->
    <div id='draw_button_sub_menu'>
        <div id='color_choice'>
            <div id='color_icon'></div>
            <div id="color_format_grid">
                <span class="color_format_label">HEX</span>
                <input type="text" id='hex_value_text' class="color_value_text" value="">
                <span class="color_format_label">HSL</span>
                <input type="text" id='hsl_value_text' class="color_value_text" value="">
                <span class="color_format_label">RGBA</span>
                <input type="text" id='rgba_value_text'class="color_value_text" value="">
            </div>
            <input type="range" id="hue_slider" class='slider' min="0" max="330" value="0">
            <input type="range" id="saturation_slider" class='slider' min="0" max="100" value="0">
            <input type="range" id="lightness_slider" class='slider' min="0" max="100" value="0">
            <input type="range" id="alpha_slider" class='slider' min="0" max="100" value="0">
            
            <div id="draw_size_grid">
                <span id="draw_size_label">BRUSH SIZE</span>
                <input type="range" id="draw_size_slider" class='slider' min="1" max="100" value="10">
                <div>
                    <div id="draw_size_circle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- side menu -->
    <div class='menu'>
        <div
            id="draw_button"
            class="menu_button"
            onclick="draw_button_click()"
        >
            <svg
                id="draw-svg"
                xmlns="http://www.w3.org/2000/svg"
                width="3rem"
                height="3rem"
                viewBox="0 0 24 24"
                fill="var(--accent-color)"
                stroke="var(--accent-color)"
                stroke-width="1"
                stroke-linecap="round"
                stroke-linejoin="round"
            >
                <polygon points="7 5  17 15  18 18  15 17  5 7" />
            </svg>
            <span id="draw_tool_tip" class="tooltip-text">a</span>
        
        </div>

        <div
            id="move_button"
            class="menu_button"
            onclick="move_mode_button_click()"
        >
            <svg
                id="move_svg" 
                xmlns="http://www.w3.org/2000/svg" 
                width="2rem" 
                height="2rem" 
                fill="var(--accent-color)" 
                stroke="var(--accent-color)" 
                class="bi bi-arrows-move" 
                viewBox="0 0 16 16"
            >
                <path fill-rule="evenodd" d="M7.646.146a.5.5 0 0 1 .708 0l2 2a.5.5 0 0 1-.708.708L8.5 1.707V5.5a.5.5 0 0 1-1 0V1.707L6.354 2.854a.5.5 0 1 1-.708-.708zM8 10a.5.5 0 0 1 .5.5v3.793l1.146-1.147a.5.5 0 0 1 .708.708l-2 2a.5.5 0 0 1-.708 0l-2-2a.5.5 0 0 1 .708-.708L7.5 14.293V10.5A.5.5 0 0 1 8 10M.146 8.354a.5.5 0 0 1 0-.708l2-2a.5.5 0 1 1 .708.708L1.707 7.5H5.5a.5.5 0 0 1 0 1H1.707l1.147 1.146a.5.5 0 0 1-.708.708zM10 8a.5.5 0 0 1 .5-.5h3.793l-1.147-1.146a.5.5 0 0 1 .708-.708l2 2a.5.5 0 0 1 0 .708l-2 2a.5.5 0 0 1-.708-.708L14.293 8.5H10.5A.5.5 0 0 1 10 8"/>
            </svg>
            <span id="move_tool_tip" class="tooltip-text">s</span>
        </div>
    </div>

    <!-- background and canvas -->
    <div id="paint-background">
        <canvas id="paint_canvas"></canvas>
    </div>




    
    <!-- 
        
        SCRIPTS

    -->


    <!-- UTIL -->
    <script>

        // CRYPTO RANDOM
        function random_crypto(min, max) {
            // Create a Uint32Array to hold the random value
            const randomBuffer = new Uint32Array(1);
            
            // Fill the array with random values
            window.crypto.getRandomValues(randomBuffer);
            
            // Scale the random value to the desired range and convert to float
            return (randomBuffer[0] / (0xFFFFFFFF + 1)) * (max - min) + min;
        }

        // UUID
        function uuidV4() {
            const uuid = new Array(36);
            for (let i = 0; i < 36; i++) {
                uuid[i] = Math.floor(random_crypto(0, 16));
            }
            uuid[14] = 4; // set bits 12-15 of time-high-and-version to 0100
            uuid[19] = uuid[19] &= ~(1 << 2); // set bit 6 of clock-seq-and-reserved to zero
            uuid[19] = uuid[19] |= (1 << 3); // set bit 7 of clock-seq-and-reserved to one
            uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
            return uuid.map((x) => x.toString(16)).join('');
        }

    </script>

    <!-- GENERAL VARAIBLES -->
    <script>
        let draw_mode = false;
        let move_mode = false;
        let dims = null;
        let width = 0;
        let height = 0;
        const canvas = document.getElementById('paint_canvas');
        let drag_x, drag_y;
        let color = {
            hue: 26,
            saturation: 100,
            lightness: 57,
            alpha: 100
        };
        let brush_radius = 10;
        
    </script>

    <!-- LAYERS AND CANVAS RENDERING -->
    <script>
        let layers = new Map();
        let uuid_to_stroke = new Map(); // uuid to stoke with pixel data
        let pixel_x_y_to_strokes = new Map();
        let current_layer = uuidV4();

        let canvas_background = {
            r: 255,
            g: 255,
            b: 255,
            a: 255
        };
        
        function init_canvas() {
            let ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let x = 0; x < canvas.width; x++) {
                for (let y = 0; y < canvas.width; y++) {
                    const index = Math.round(y * canvas.width + x) * 4; // Calculate index for the pixel
                    imageData.data[index] = canvas_background.r;     // Red
                    imageData.data[index + 1] = canvas_background.g;   // Green
                    imageData.data[index + 2] = canvas_background.b;   // Blue
                    imageData.data[index + 3] = canvas_background.a; // Alpha
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function re_draw() {

            const start = performance.now();
            init_canvas();
            for (const [layer_uuid, layer] of layers.entries()) {
                for (let stroke_uuid of layer.strokes) {
                    set_pixels(uuid_to_stroke.get(stroke_uuid).pixels);
                }
            }
            console.log("completed re-draw", performance.now() - start, "ms");
            // console.log("layers", layers);
        }

        function mouse_x_to_canvas_x(x) {
            const canvas_width = parseFloat(canvas.style.width);
            const zoom_factor = canvas_width / dims.defaultWidth;
            x = x + window.scrollX - CANVAS_X;
            return Math.floor(x / zoom_factor);
        }

        function mouse_y_to_canvas_y(y) {
            const canvas_width = parseFloat(canvas.style.width);
            const zoom_factor = canvas_width / dims.defaultWidth;
            y = y + window.scrollY - CANVAS_Y;
            return Math.floor(y / zoom_factor);
        }
    


        // DRAWING STROKES
        let stroke_uuid = uuidV4();
        let stroke_path_checker = new Set();
        let pixel_checker = new Set();
        let stroke = {
            layer_uuid: current_layer,
            pixels: []
        };
        function finish_stroke() {

            if (layers.has(current_layer)) {
                layers.get(current_layer).strokes.push(stroke_uuid);
            }
            else {
                layers.set(
                    current_layer, 
                    {
                        strokes: [stroke_uuid]
                    }
                );
            }


            uuid_to_stroke.set(stroke_uuid, {
                layer_uuid: current_layer,
                pixels: []
            });
            
            for (const pixel of stroke.pixels) {
                uuid_to_stroke.get(stroke_uuid).pixels.push(
                    {
                        x: pixel.x,
                        y: pixel.y,
                        r: pixel.r,
                        g: pixel.g,
                        b: pixel.b,
                        a: pixel.a
                    }
                );
            }
            // console.log("new stroke", stroke_uuid, uuid_to_stroke);


            // reset temp vars
            stroke_uuid = uuidV4();
            stroke = {
                layer_uuid: current_layer,
                pixels: []
            };
            stroke_path_checker.clear();
            pixel_checker.clear();



        }

        function add_to_stroke(pixels, apply_radius) {

            // console.log("pixels before", pixels);

            // remove any duplicates
            pixels = pixels.filter(pixel => {
                const tag = `${pixel.x}_${pixel.y}`;
                if (!stroke_path_checker.has(tag)) {
                    stroke_path_checker.add(tag);
                    if (pixel_x_y_to_strokes.has(tag)) {
                        pixel_x_y_to_strokes.get(tag).push(stroke_uuid);
                    }
                    else {
                        pixel_x_y_to_strokes.set(tag, [stroke_uuid]);
                    }
                    return true;
                }
                else {
                    return false;
                }
            });
            

            // add stroke radius
            // console.log("brush_radius", brush_radius);
            // console.log("pixels", pixels);
            let brush_pixels = [];
            const half_radius = Math.floor(brush_radius / 2);
            for (let x = -half_radius; x < half_radius; x++) {
                for (let y = -half_radius; y < half_radius; y++) {

                    let dist = Math.sqrt(
                        Math.pow(x, 2) +
                        Math.pow(y, 2)
                    );
                    if (dist < half_radius) {
                        brush_pixels.push({
                            x: x,
                            y: y
                        });
                    }
                    
                }
            }
            if (apply_radius) {
                pixels = pixels.flatMap(pixel => {
                    const start_x = pixel.x - brush_radius;
                    const end_x = pixel.x + brush_radius;
                    const start_y = pixel.y - brush_radius;
                    const end_y = pixel.y + brush_radius;

                    let radius_pixels = [];
                    let tag = `${pixel.x}_${pixel.y}`;
                    if (!pixel_checker.has(tag)) {
                        radius_pixels.push(pixel);
                    }
                    for (const brush_pixel of brush_pixels) {
                        const x = pixel.x + brush_pixel.x;
                        const y = pixel.y + brush_pixel.y;
                        tag = `${x}_${y}`;
                        if (!pixel_checker.has(tag) && !stroke_path_checker.has(tag)) {
                            pixel_checker.add(tag);
                            radius_pixels.push({
                                x: x,
                                y: y,
                                r: pixel.r,
                                g: pixel.g,
                                b: pixel.b,
                                a: pixel.a
                            });

                            if (pixel_x_y_to_strokes.has(tag)) {
                                pixel_x_y_to_strokes.get(tag).push(stroke_uuid);
                            }
                            else {
                                pixel_x_y_to_strokes.set(tag, [stroke_uuid]);
                            }
                        }
                    }

                    return radius_pixels;
                });
            }
            // console.log("pixels after", pixels);


            stroke.pixels.push(...pixels);
            
            set_pixels(pixels);
        }


        /*
            pixels is an array of pixel objects with an x, y, and rgba color value
        */
        function set_pixels(pixels) {
            // console.log("set_pixels");

            let ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            // console.log("pixels", pixels);

            pixels.forEach((pixel) => {

                if (pixel.x < canvas.width && pixel.y < canvas.height && pixel.x > 0 && pixel.y > 0) {
                    const index = Math.round(pixel.y * canvas.width + pixel.x) * 4; // Calculate index for the pixel

                    // Set the alpha composite pixel color (R, G, B, A)
                    const r_b = imageData.data[index];
                    const g_b = imageData.data[index + 1];
                    const b_b = imageData.data[index + 2];
                    const a_b = imageData.data[index + 3] / 255;
                    const r_s = pixel.r;
                    const g_s = pixel.g;
                    const b_s = pixel.b;
                    const a_s = pixel.a / 255;

                    // Calculate the resulting alpha
                    const a_r = a_s + (a_b * (1 - a_s));

                    const r_r = (r_s * a_s + r_b * a_b * (1 - a_s)) / a_r;
                    const g_r = (g_s * a_s + g_b * a_b * (1 - a_s)) / a_r;
                    const b_r = (b_s * a_s + b_b * a_b * (1 - a_s)) / a_r;
                    // console.log("r_b", r_b, "g_b", g_b, "b_b", b_b);
                    // console.log("r_s", r_s, "g_s", g_s, "b_s", b_s);
                    // console.log("r_r", r_r, "g_r", g_r, "b_r", b_r);

                    // Calculate and set the resulting color
                    imageData.data[index] = r_r;     // Red
                    imageData.data[index + 1] = g_r;   // Green
                    imageData.data[index + 2] = b_r;   // Blue
                    imageData.data[index + 3] = a_r * 255; // Alpha

                }
            });
            ctx.putImageData(imageData, 0, 0);
        }


        // MOVING STROKES
        let canvas_data_without_selected_stroke = null;
        let selected_stroke_uuid = null;
        let selected_stroke = null;
        let delta_x_sum = 0;
        let delta_y_sum = 0;
        function save_canvas_and_get_selected_stroke (x, y) {

            console.log("save_canvas_and_get_selected_stroke");
            // console.log("uuid_to_stroke", uuid_to_stroke);

            // get selected stroke
            const tag = `${x}_${y}`;
            const selected_stroke_uuids = pixel_x_y_to_strokes.get(tag);


            if (selected_stroke_uuids) {
                selected_stroke_uuid = selected_stroke_uuids[selected_stroke_uuids.length - 1];
                // console.log("selected_stroke_uuids", selected_stroke_uuids);
                // console.log("selected_stroke_uuid", selected_stroke_uuid);

                // console.log("uuid_to_stroke", uuid_to_stroke);
                selected_stroke =  uuid_to_stroke.get(selected_stroke_uuid);
                uuid_to_stroke.delete(selected_stroke_uuid);


                if (selected_stroke) {
                    // remove stroke and redraw canvas
                    current_layer = selected_stroke.layer_uuid;
                    // console.log('layers', layers);
                    let other_strokes = layers.get(current_layer).strokes.filter(uuid => uuid != selected_stroke_uuid);
                    layers.get(current_layer).strokes = other_strokes
                    // console.log('other_strokes', other_strokes);
                    // console.log('layers.get(current_layer).strokes', layers.get(current_layer).strokes);
                    // console.log('layers', layers);

                    selected_stroke.pixels.forEach(pixel => {
                        const tag = `${pixel.x}_${pixel.y}`;
                        pixel_x_y_to_strokes.set(
                            tag, 
                            pixel_x_y_to_strokes.get(tag).filter(uuid => uuid !== selected_stroke_uuid)
                        );
                    });

                    // re-draw canvas and save image buffer
                    re_draw();
                    let ctx = canvas.getContext('2d');
                    canvas_data_without_selected_stroke = ctx.getImageData(0, 0, canvas.width, canvas.height);

                    set_pixels(selected_stroke.pixels);

                    return selected_stroke_uuid;
                }

            }

            return null;
        }
    
        function update_selected_stroke(clientX, clientY) {
            // console.log("update_selected_stroke");
            // console.log("selected_stroke_uuid", selected_stroke_uuid);

            if (selected_stroke) {
                
                // update stroke pixels
                const canvas_width = parseFloat(canvas.style.width);
                const zoom_factor = canvas_width / dims.defaultWidth;
                // console.log("zoom_factor", zoom_factor);
                delta_x_sum += (clientX - drag_x) / zoom_factor;
                delta_y_sum += (clientY - drag_y) / zoom_factor;
                let delta_x = Math.floor(delta_x_sum);
                let delta_y = Math.floor(delta_y_sum);
                delta_x_sum -= delta_x;
                delta_y_sum -= delta_y;


                selected_stroke.pixels = selected_stroke.pixels.map(pixel => {
                    pixel.x += delta_x;
                    pixel.y += delta_y;

                    return pixel;
                });

                // draw saved canvas
                let ctx = canvas.getContext('2d');
                ctx.putImageData(canvas_data_without_selected_stroke, 0, 0);

                // // draw selected stroke
                // init_canvas();
                set_pixels(selected_stroke.pixels);

            }
        }

        function drop_selected_stroke() {
            console.log("drop_selected_stroke");
            
            if (selected_stroke_uuid) {

                // draw saved canvas
                let ctx = canvas.getContext('2d');
                ctx.putImageData(canvas_data_without_selected_stroke, 0, 0);

                // re-add stroke
                add_to_stroke(selected_stroke.pixels, false);
                finish_stroke();

                // draw stroke
                // set_pixels(selected_stroke.pixels);

                // reset temp varaibles
                uuid_to_stroke.delete(selected_stroke_uuid);
                canvas_data_without_selected_stroke = null;
                selected_stroke_uuid = null;
                selected_stroke = null;
            }
            
        }
    
    </script>

    <!-- DRAW MODE MENUS -->
    <script>
        

        function hsla_to_rgba(h, s, l, a) {
            // Normalize hue to [0, 360]
            h = h % 360;
            // Normalize saturation and lightness to [0, 1]
            s /= 100;
            l /= 100;

            let r, g, b;

            if (s === 0) {
                // Achromatic (gray)
                r = g = b = l * 255;
            } else {
                const c = (1 - Math.abs(2 * l - 1)) * s; // Chroma
                const x = c * (1 - Math.abs((h / 60) % 2 - 1)); // Secondary component
                const m = l - c / 2; // Match lightness

                // Determine RGB values based on hue
                if (h >= 0 && h < 60) {
                    r = c; g = x; b = 0;
                } else if (h >= 60 && h < 120) {
                    r = x; g = c; b = 0;
                } else if (h >= 120 && h < 180) {
                    r = 0; g = c; b = x;
                } else if (h >= 180 && h < 240) {
                    r = 0; g = x; b = c;
                } else if (h >= 240 && h < 300) {
                    r = x; g = 0; b = c;
                } else {
                    r = c; g = 0; b = x;
                }

                // Adjust for lightness
                r = Math.round((r + m) * 255);
                g = Math.round((g + m) * 255);
                b = Math.round((b + m) * 255);
            }

            // Return RGBA values
            return {
                r: r,
                g: g,
                b: b,
                a: Math.round(a * 2.55) 
            };
        }

        function rgba_to_hex(r, g, b, a) {

            // Ensure R, G, B are in the range [0, 255]
            r = Math.min(255, Math.max(0, Math.round(r)));
            g = Math.min(255, Math.max(0, Math.round(g)));
            b = Math.min(255, Math.max(0, Math.round(b)));
            

            if (a == 255) {
                // Convert R, G, B, and A to hex and pad with zeros
                const hex = (r << 16 | g << 8 | b) >>> 0; // Ensure unsigned
                return `#${('000000' + hex.toString(16)).slice(-6)}`; // Format as 8-digit hex
            }
            else {
                // Convert R, G, B, and A to hex and pad with zeros
                const hex = (r << 16 | g << 8 | b | (a << 24)) >>> 0; // Ensure unsigned
                return `#${('00000000' + hex.toString(16)).slice(-8)}`; // Format as 8-digit hex
            }
            
        }

        function draw(client_x_start, client_x_end, client_y_start, client_y_end) {

            let color_rgba = hsla_to_rgba(color.hue, color.saturation, color.lightness, color.alpha);
            // console.log("color", color);
            // console.log("color_rgba", color_rgba);

            let mouse_x = client_x_start + window.scrollX - CANVAS_X;
            let mouse_y = client_y_start + window.scrollY - CANVAS_Y;
            let mouse_drag_x = client_x_end + window.scrollX - CANVAS_X;
            let mouse_drag_y = client_y_end + window.scrollY - CANVAS_Y;

            const canvas_width = parseFloat(canvas.style.width);
            const zoom_factor = canvas_width / dims.defaultWidth;

            // draw line from previous point to new point
            let pixels = [];
            let dist_x = mouse_x - mouse_drag_x;
            let dist_y = mouse_y - mouse_drag_y;
            let max_dist = Math.max(Math.abs(dist_x), Math.abs(dist_y));
            let step_x = dist_x / max_dist;
            let step_y = dist_y / max_dist;
            for (let i = 0; i < max_dist; i++) {
                let x = step_x * i + mouse_drag_x;
                let y = step_y * i + mouse_drag_y;
                const pixel = {
                    x: Math.floor(x / zoom_factor),
                    y: Math.floor(y / zoom_factor),
                    r: color_rgba.r,
                    g: color_rgba.g,
                    b: color_rgba.b,
                    a: color_rgba.a
                };
                pixels.push(pixel);
            }
            const pixel = {
                x: Math.floor(mouse_x / zoom_factor),
                y:  Math.floor(mouse_y / zoom_factor),
                r: color_rgba.r,
                g: color_rgba.g,
                b: color_rgba.b,
                a: color_rgba.a
            };
            pixels.push(pixel);

            // console.log("color", color);
            // console.log("color_rgba", color_rgba);
            // console.log("pixels", pixels);
            add_to_stroke(pixels, true);


            // console.log("dims.defaultWidth", dims.defaultWidth);
            // console.log("canvas_width", canvas_width);
            // console.log("zoom_factor", zoom_factor);
            // console.log("event.clientX:", event.clientX, "event.clientY:", event.clientY);
            // console.log("window.scrollX:", window.scrollX, "window.scrollY:", window.scrollY);
            // console.log("adj x:", event.clientX + window.scrollX, "adj y", event.clientY + window.scrollY);
            // console.log("x:", mouse_x, "y:", mouse_y);
        }


        const color_icon = document.getElementById('color_icon');

        const draw_size_circle = document.getElementById('draw_size_circle');


        const hue_slider = document.getElementById('hue_slider');
        const saturation_slider = document.getElementById('saturation_slider');
        const lightness_slider = document.getElementById('lightness_slider');
        const alpha_slider = document.getElementById('alpha_slider');

        function update_hue_slider() {
            hue_slider.style.background = `linear-gradient(to right, 
                hsl(0, ${color.saturation}%, ${color.lightness}%, ${color.alpha}%),
                hsl(30, ${color.saturation}%, ${color.lightness}%, ${color.alpha}%),
                hsl(60, ${color.saturation}%, ${color.lightness}%, ${color.alpha}%),
                hsl(90, ${color.saturation}%, ${color.lightness}%, ${color.alpha}%),
                hsl(120, ${color.saturation}%, ${color.lightness}%, ${color.alpha}%),
                hsl(150, ${color.saturation}%, ${color.lightness}%, ${color.alpha}%),
                hsl(180, ${color.saturation}%, ${color.lightness}%, ${color.alpha}%),
                hsl(210, ${color.saturation}%, ${color.lightness}%, ${color.alpha}%),
                hsl(240, ${color.saturation}%, ${color.lightness}%, ${color.alpha}%),
                hsl(270, ${color.saturation}%, ${color.lightness}%, ${color.alpha}%),
                hsl(300, ${color.saturation}%, ${color.lightness}%, ${color.alpha}%),
                hsl(330, ${color.saturation}%, ${color.lightness}%, ${color.alpha}%)
            )`;
        }

        function update_saturation_slider() {
            saturation_slider.style.background = `linear-gradient(to right, 
                hsl(${color.hue}, 0%, ${color.lightness}%, ${color.alpha}%),
                hsl(${color.hue}, 50%, ${color.lightness}%, ${color.alpha}%),
                hsl(${color.hue}, 100%, ${color.lightness}%, ${color.alpha}%)
            )`;
        }

        function update_lightness_slider() {
            lightness_slider.style.background = `linear-gradient(to right, 
                hsl(${color.hue}, ${color.saturation}%, 0%, ${color.alpha}%),
                hsl(${color.hue}, ${color.saturation}%, 10%, ${color.alpha}%),
                hsl(${color.hue}, ${color.saturation}%, 20%, ${color.alpha}%),
                hsl(${color.hue}, ${color.saturation}%, 30%, ${color.alpha}%),
                hsl(${color.hue}, ${color.saturation}%, 40%, ${color.alpha}%),
                hsl(${color.hue}, ${color.saturation}%, 50%, ${color.alpha}%),
                hsl(${color.hue}, ${color.saturation}%, 60%, ${color.alpha}%),
                hsl(${color.hue}, ${color.saturation}%, 70%, ${color.alpha}%),
                hsl(${color.hue}, ${color.saturation}%, 80%, ${color.alpha}%),
                hsl(${color.hue}, ${color.saturation}%, 90%, ${color.alpha}%),
                hsl(${color.hue}, ${color.saturation}%, 100%, ${color.alpha}%)
            )`;
        }

        function update_alpha_slider() {
            alpha_slider.style.background = `linear-gradient(to right, 
                hsl(${color.hue}, ${color.saturation}%, ${color.lightness}%, 0%),
                hsl(${color.hue}, ${color.saturation}%, ${color.lightness}%, 10%),
                hsl(${color.hue}, ${color.saturation}%, ${color.lightness}%, 20%),
                hsl(${color.hue}, ${color.saturation}%, ${color.lightness}%, 30%),
                hsl(${color.hue}, ${color.saturation}%, ${color.lightness}%, 40%),
                hsl(${color.hue}, ${color.saturation}%, ${color.lightness}%, 50%),
                hsl(${color.hue}, ${color.saturation}%, ${color.lightness}%, 60%),
                hsl(${color.hue}, ${color.saturation}%, ${color.lightness}%, 70%),
                hsl(${color.hue}, ${color.saturation}%, ${color.lightness}%, 80%),
                hsl(${color.hue}, ${color.saturation}%, ${color.lightness}%, 90%),
                hsl(${color.hue}, ${color.saturation}%, ${color.lightness}%, 100%)
            )`;
        }

        hue_slider.addEventListener('input', () => {
            color.hue = hue_slider.value;
            update_saturation_slider();
            update_lightness_slider();
            update_alpha_slider();
            update_color_label();
        });

        saturation_slider.addEventListener('input', () => {
            color.saturation = saturation_slider.value;
            update_hue_slider();
            update_lightness_slider();
            update_alpha_slider();
            update_color_label();
        });

        lightness_slider.addEventListener('input', () => {
            color.lightness = lightness_slider.value;
            update_hue_slider();
            update_saturation_slider();
            update_alpha_slider();
            update_color_label();
        });

        alpha_slider.addEventListener('input', () => {
            color.alpha = alpha_slider.value;
            update_hue_slider();
            update_saturation_slider();
            update_lightness_slider();
            update_color_label();
        });

        function update_color_label() {
            color_icon.style.backgroundColor = `hsl(${color.hue}, ${color.saturation}%, ${color.lightness}%, ${color.alpha}%)`;
            draw_size_circle.style.backgroundColor = `hsl(${color.hue}, ${color.saturation}%, ${color.lightness}%, ${color.alpha}%)`;
            

            const rgba = hsla_to_rgba(color.hue, color.saturation, color.lightness, color.alpha);
            document.getElementById("hex_value_text").value = rgba_to_hex(rgba.r, rgba.g, rgba.b, rgba.a);

            document.getElementById("hsl_value_text").value = `${color.hue}Â°, ${color.saturation}%, ${color.lightness}%, ${color.alpha}%`;

            document.getElementById("rgba_value_text").value = `${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a}`;
        }

        function draw_button_click() {
            // console.log("clicked");


            if (move_mode) {
                move_mode_button_click();
            }
            draw_mode = !draw_mode;

            const draw_button = document.getElementById("draw_button");
            const draw_svg = document.getElementById("draw-svg");
            

            if (draw_mode) {
                draw_button.style.backgroundColor = 'var(--accent-color)';
                draw_svg.setAttribute('fill', 'var(--secondary-color)');
                draw_svg.setAttribute('stroke', 'var(--secondary-color)');
            }
            else {
                draw_button.style.backgroundColor = 'var(--secondary-color)';
                draw_svg.setAttribute('fill', 'var(--accent-color)');
                draw_svg.setAttribute('stroke', 'var(--accent-color)');
            }
            toggle_draw_sub_menu();
            // draw_button.classList.remove("draw_button-selected");
        }

        function toggle_draw_sub_menu() {
            if (draw_mode) {
                place_draw_sub_menu();
            }
            else {
                const draw_sub_menu = document.getElementById('draw_button_sub_menu');
                draw_sub_menu.style.display = 'none';
            }
        }

        function place_draw_sub_menu() {
            const draw_button = document.getElementById('draw_button');
            const draw_sub_menu = document.getElementById('draw_button_sub_menu');
            draw_sub_menu.style.display = 'flex';

            const rect = draw_button.getBoundingClientRect();
            draw_sub_menu.style.top = (rect.top) + 'px';
            draw_sub_menu.style.left = (rect.right + 5) + 'px';

            hue_slider.value = color.hue;
            saturation_slider.value = color.saturation;
            lightness_slider.value = color.lightness;
            alpha_slider.value = color.alpha;
        }



        const draw_size_slider = document.getElementById('draw_size_slider');
        draw_size_slider.addEventListener('input', () => {
            brush_radius = draw_size_slider.value;
            draw_size_circle.style.width = brush_radius + "px";
            draw_size_circle.style.height = brush_radius + "px";
            draw_size_circle.style.borderRadius = brush_radius + "px";
        });
        draw_size_slider.value = brush_radius;

        update_color_label();
    </script>

    <!-- MOVE MODE -->
    <script>


        function move_mode_button_click() {
            // console.log("clicked");

            if (draw_mode) {
                draw_button_click();
            }
            move_mode = !move_mode;

            const move_mode_button = document.getElementById("move_button");
            const move_svg = document.getElementById("move_svg");
            

            if (move_mode) {
                move_mode_button.style.backgroundColor = 'var(--accent-color)';
                move_svg.setAttribute('fill', 'var(--secondary-color)');
                move_svg.setAttribute('stroke', 'var(--secondary-color)');
            }
            else {
                move_mode_button.style.backgroundColor = 'var(--secondary-color)';
                move_svg.setAttribute('fill', 'var(--accent-color)');
                move_svg.setAttribute('stroke', 'var(--accent-color)');
            }


        }

        function toggle_draw_sub_menu() {
            if (draw_mode) {
                place_draw_sub_menu();
            }
            else {
                const draw_sub_menu = document.getElementById('draw_button_sub_menu');
                draw_sub_menu.style.display = 'none';
            }
        }

    </script>

    <!-- GENERAL INPUT HANDLING -->
    <script>
        const CANVAS_X = 40000; 
        const CANVAS_Y = 40000; 


        document.addEventListener('DOMContentLoaded', () => {
            let windowWidth = window.innerWidth;
            let windowHeight = window.innerHeight;
            dims = get_default_canvas_dims(); // Define this function for your dimensions
            width = dims.defaultWidth;
            height = dims.defaultHeight;
            let ctrl = false; // Control flag

            // Set initial canvas size
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.width = width;
            canvas.height = height;
            init_canvas();

            // const rect = canvas.getBoundingClientRect();
            // let canvasX = rect.left + window.scrollX;
            // let canvasY = rect.top + window.scrollY;
            // console.log('canvasX', canvasX);
            // console.log('canvasY', canvasY);

            // Center the scroll
            window.scrollTo(CANVAS_X - windowWidth / 2 + width / 2, CANVAS_Y - windowHeight / 2 + height / 2);
            console.log('window:', windowWidth, windowHeight);
            // console.log('width', width);
            // console.log('height', height);
            // console.log('windowWidth', windowWidth);
            // console.log('windowHeight', windowHeight);

            // starter_stroke(100, 100);
            // starter_stroke(300, 100);


            return () => {
            };
        });

        const handleKeyDown = (event) => {
            if ((event.ctrlKey && event.key === 'Control') || (event.metaKey && event.key === 'Meta')) {
                ctrl = true;
            }
            else if (!event.ctrlKey && event.key === 'a') {
                draw_button_click();
            }
            else if (!event.ctrlKey && event.key === 's') {
                move_mode_button_click();
            }
        };
        window.addEventListener('keydown', handleKeyDown);
        
        const handleKeyUp = (event) => {
            if (event.key === 'Control' || event.key === 'Meta') {
                ctrl = false;
            }
        };
        window.addEventListener('keyup', handleKeyUp);
        
        let is_dragging = false;
        const handleMouseDown = (event) => {
            if (event.button == 0) {
                is_dragging = true; // Set dragging to true
                drag_x = event.clientX; // Get the starting X coordinate
                drag_y = event.clientY; // Get the starting Y coordinate

                if (draw_mode && event.target == canvas) {
                    draw(event.clientX, event.clientX, event.clientY, event.clientY);
                }
                else if (move_mode && event.target == canvas) {
                    let x = mouse_x_to_canvas_x(event.clientX);
                    let y = mouse_y_to_canvas_y(event.clientY);
                    save_canvas_and_get_selected_stroke(x, y);
                }
            }
        };
        window.addEventListener('mousedown', handleMouseDown);
        
        const handleMouseMove = (event) => {
            if (is_dragging && event.target == canvas) {
                if (draw_mode) {
                    draw(event.clientX, drag_x, event.clientY, drag_y);
                }
                else if (move_mode) {
                    update_selected_stroke(event.clientX, event.clientY);
                }
                else {
                    const delta_x = event.clientX - drag_x;
                    const delta_y = event.clientY - drag_y;
                    window.scrollTo(window.scrollX - delta_x, window.scrollY - delta_y);
                }

                drag_x = event.clientX;
                drag_y = event.clientY;
            }
        };
        window.addEventListener('mousemove', handleMouseMove);
        
        const handleMouseUp = (event) => {
            is_dragging = false;
            if (event.target == canvas) {
                if (draw_mode) {
                    finish_stroke();
                }
                else if (move_mode) {
                    drop_selected_stroke();
                }
            }
        };
        window.addEventListener('mouseup', handleMouseUp);

        let zoom = 8; // Default zoom level
        const handleScroll = (event) => {
            event.preventDefault(); // Prevent default scroll action
            
            // determine mouse location on canvas
            let mouseX = event.clientX; // gets absolute mouse pos not just in viewport
            let mouseY = event.clientY;
            const canvas_location_x_percent = (mouseX + window.scrollX - CANVAS_X) / width;
            const canvas_location_y_percent = (mouseY + window.scrollY - CANVAS_Y) / height;
            // console.log('canvas_location_x_percent', canvas_location_x_percent);
            // console.log('canvas_location_y_percent', canvas_location_y_percent);



            // console.log("zooming");
            let scrollAmount = -event.deltaY;
            zoom += scrollAmount / 1200;
            if (zoom < 8) zoom = 8; // Minimum zoom
            if (zoom > 9) zoom = 9; // Maximum zoom

            let zoomFactor = 100 * 100 ** (zoom - 9);
            // console.log('zoomFactor', zoomFactor);

            // Modify canvas size
            width = dims.defaultWidth * zoomFactor;
            height = dims.defaultHeight * zoomFactor;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            // Center the zoom on mouse position
            // console.log('mouseX', mouseX);
            // console.log('mouseY', mouseY);
            // console.log('width', width);
            // console.log('height', height);

            /*

                determine pixel where mouse is
                determine same pixel in new canvas

                determine mouse distance from center screen
            */

            const canvas_location_x = canvas_location_x_percent * width;
            const canvas_location_y = canvas_location_y_percent * height;
            const mouse_offset_x = mouseX;
            const mouse_offset_y = mouseY;
            // console.log('mouse_offset_x', mouse_offset_x);
            // console.log('mouse_offset_y', mouse_offset_y);

            window.scrollTo({
                left: 40000 - mouse_offset_x + canvas_location_x,   // X position
                top: 40000 - mouse_offset_y + canvas_location_y,    // Y position
                // behavior: 'smooth' // Enables smooth scroll
            });

            // redraw open menus
            if (draw_mode){
                place_draw_sub_menu();

            }
        };
        window.addEventListener('wheel', handleScroll, { passive: false });
        

        // Function to get default canvas dimensions
        function get_default_canvas_dims() {
            
            let windowWidth = window.innerWidth;
            let defaultWidth = windowWidth * 0.6;
            let defaultHeight = defaultWidth * 1080 / 1920;
        
            return { defaultWidth, defaultHeight };
        }


        // DELETE THIS testing stuff
        draw_button_click();


        // TEST
        function starter_stroke(start_x, start_y) {
            let pixels = [];
            for (let x = start_x; x < start_x + 100; x++) {
                for (let y = start_y; y < start_y + 100; y++) {
                    const pixel = {
                        x: x,
                        y: y,
                        r: 255,
                        g: 0,
                        b: 0,
                        a: 255
                    };
                    pixels.push(pixel);
                }
            }

            add_to_stroke(pixels, false);
            finish_stroke();
        }
    </script>


    <!-- TOOLTIPS PLACEMENTS -->

    <script>
        const draw_button = document.getElementById('draw_button');
        const draw_tool_tip = document.getElementById('draw_tool_tip');
        let rect = draw_button.getBoundingClientRect();
        let offset = rect.width * .8;
        draw_tool_tip.style.top = (rect.top + offset) + 'px';
        draw_tool_tip.style.left = (rect.left + offset) + 'px';

        const move_button = document.getElementById('move_button');
        const move_tool_tip = document.getElementById('move_tool_tip');
        rect = move_button.getBoundingClientRect();
        offset = rect.width * .8;
        move_tool_tip.style.top = (rect.top + offset) + 'px';
        move_tool_tip.style.left = (rect.left + offset) + 'px';
    </script>

</body>
</html>